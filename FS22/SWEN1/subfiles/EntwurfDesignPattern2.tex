\documentclass[../ZF_SWEN1.tex]{subfiles}
\begin{document}

\subsection{Decorator}
\begin{itemize}
	\item Problem
	\begin{itemize}
		\item Objekt(nicht eine ganze Klasse) soll mit zusätzlichen Verantwortlichkeiten versehen werden.
	\end{itemize}
	\item Lösung
	\begin{itemize}
		\item Decorator, der dieselbe Schnittstelle hat wir das ursprüngliche Objekt, wird vor dieses geschaltet. Decorator kann nun jeden Methodenaufruf entweder 
		\begin{enumerate}
			\item selber bearbeiten,
			\item ihn an das ursprüngliche Objekt weiterleiten oder
			\item eine Mischung aus beidem machen.
		\end{enumerate}
 
	\end{itemize}
	\item Hinweise
	\begin{itemize}
		\item Strukturell identisch mit dem Proxy Design Pattern. Hat aber andere Absicht.
		\item Identisch mit Composite Design Pattern wenn Anzahl Elemente 1 ist. Hat aber andere Absicht.
	\end{itemize}
\end{itemize}




\subsection{Observer}
\begin{itemize}
	\item \textbf{Problem}
	\begin{itemize}
		\item Objekt soll ein anderes Objekt benachrichtigen, ohne Typ des Empfängers zu kennen.
	\end{itemize}
	\item \textbf{Lösung}
	\begin{itemize}
		\item Interface definieren, dient nur dazu, Objekt über eine Änderung zu informieren. Interface vom Observer implementiert. Observable Objekt benachrichtigt ale registrierten Observer über eine Änderung.
	\end{itemize}
	\item \textbf{Hinweise}
	\begin{itemize}
		\item (Observer-Observable) = (Publisher-Subscriber)= (Listener-Observable)
		\item Observable kennt nur Observer aber nicht wahren Typ
		\item 2 Phasen:
		\begin{enumerate}
			\item Registrierung vom Observer
			\item Benachrichtigung vom Observable
		\end{enumerate}
	\end{itemize}
	\item \textbf{Erweiterung}
	\begin{itemize}
		\item Mithilfe Mediatior Pattern kann ein Objekt zwischen Observer und Observable vermitteln. Sowohl Objekt wie auch Observable registrieren sich bei diesem Objekt. Beide benennen eine Eventquelle, die Observer abonniert und Observable mit Events bedient.
		\item Beispiel:
		\begin{itemize}
			\item IoT mit Netzwerkprotokoll MQTT- Server/Client verwendet dieses Prinzip
		\end{itemize}
	\end{itemize}
\end{itemize}



\subsection{Strategy}
\begin{itemize}
	\item \textbf{Problem}
	\begin{itemize}
		\item Algorithmus soll einfach austauschbar sein
	\end{itemize}
	\item \textbf{Lösung}
	\begin{itemize}
		\item Algorithmus in eine eigene Klasse verschieben, die nur eine Methode mit diesem Algorithmus hat.
		\item Interface für diese Klasse definieren, das von alternativen Algorithmen implementiert werden muss.
	\end{itemize}
	\item \textbf{Hinweise}
	\begin{itemize}
		\item Motivation: technische oder fachspezifische Gründe zur Austauschung
		\item Interface:
		\begin{itemize}
			\item Nur eine Methode
			\item Parameter: Alle Daten übergeben welche Algorithmus benötigt. Parameter heisst Context.
		\end{itemize}
	\end{itemize}
\end{itemize}



\subsection{Composite}
\begin{itemize}
	\item \textbf{Problem}
	\begin{itemize}
		\item Menge von Objekten haben dasselbe Interface und müssen für viele Verantwortlichkeiten als Gesamtheit betrachtet werden.
	\end{itemize}
	\item \textbf{Lösung}
	\begin{itemize}
		\item Composite definieren, das dasselbe Interface implementiert und Methoden an die darin enthaltenen objekte weiterleitet.
	\end{itemize}
	\item \textbf{Hinweise}
	\begin{itemize}
		\item Hierarchische Struktur of vom Fachgebiet gegeben
		\item Nicht alle Methoden delegieren einfach auf enthaltenen Elemente. vor- und Nachbearbeitung ist üblich. Gewisse Methoden müssen ganz anders implementiert werden.
	\end{itemize}
\end{itemize}



\subsection{State}
\begin{itemize}
	\item \textbf{Problem}
	\begin{itemize}
		\item Verhalten eines Objekts ist abhängig von seinem inneren Zustand
	\end{itemize}
	\item \textbf{Lösung}
	\begin{itemize}
		\item Objekt hat ein darin enthaltenes Zustandsobjekt
		\item Alle Methoden, deren Verhalten vom Zustand abhängig sind, über Zustandsobjekt geführt.
	\end{itemize}
	\item \textbf{Hinweise}
	\begin{itemize}
		\item Zustands-Klassen implementieren Zustand-Interface
		\item Zustands-Objekte sind nichts anderes als Strategy Objekte und können Singletons sein.
		\item Zustandsobjekt hat entweder direkt den Code (als innere Klasse) oder delegiert an eine Methode des Objekts weiter.
	\end{itemize}
	\item \textbf{Allgemein}
	\begin{itemize}
		\item In Geschäftsanwendungen State Pattern selten. Häufig in technischen Anwendungen wie Protokollhandler oder Maschinensteuerungen.
	\end{itemize}
	\item Forum(Inklusive Code)
	\begin{itemize}
		\item Verschiedene Stufe der Änderungsmöglichkeiten
	\end{itemize}
\end{itemize}

\subsection{Visitor}
\begin{itemize}
	\item \textbf{Problem}
	\begin{itemize}
		\item Klassenhierarchie um Verantwortlichkeiten (weniger wichtige) erweitert werden, ohne dass viele neue Methoden hinzukommen
	\end{itemize}
	\item \textbf{Lösung}
	\begin{itemize}
		\item Klassenhierarchie mit einer Visitor-Infrastruktur erweitern
		\item Alle weiteren neuen Verantwortlichkeiten mit spezigischen Visitor-Klassen realisiert
	\end{itemize}
	\item \textbf{Hinweise}
	\begin{itemize}
		\item Widerspruch zum Information Expert. Darum wiichtige Methoden weiterhin direkt der Klasse hinzufügen
		\item Oft Auswertungen an Visitor-Klassen delegieren
		\item Frage bei mehrstufigen Objekthierarchie. wer die darin enthaltenen Elemente aufruft.
	\end{itemize}
\end{itemize}



\subsection{Facade}
\begin{itemize}
	\item \textbf{Problem}
	\begin{itemize}
		\item Einsatz kompliziertes Subsystem mit vielen Klassen. Wie Verwendung vereinfachen, so dass alle Team-Mitglieder es korrekt und einfach verwenden?
	\end{itemize}
	\item \textbf{Lösung}
	\begin{itemize}
		\item Facade Klasse diefinieren,die vereinfachte Schnittstelle zum Subsystem anbietet und die meisten Anwendungen abdeckt.
	\end{itemize}
	\item \textbf{Hinweise}
	\begin{itemize}
		\item Facade vs Adapter: Fassade kapselt Subsystem nicht vollständig. Erlaubt dass Methoden der Facade Parameter und Rückgabewerte haben, die Bezug auf das Subsystem nehmen.
		\item Oft vom Ersteller eines Frameworks entwickelt
	\end{itemize}
\end{itemize}





















































































































































\end{document}