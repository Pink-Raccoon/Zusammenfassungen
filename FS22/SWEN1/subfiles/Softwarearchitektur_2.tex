\documentclass[../ZF_SWEN1.tex]{subfiles}

\begin{document}

\subsection{Objektorientierung}

\paragraph{Grundidee: } Reale Welt besteht aus Objekten, die untereinander in Beziehungen stehen.

\begin{itemize}
	\item Klasse:
	\begin{itemize}
		\item Daten(Attribute)
		\item Funktionalität(Operationen, Methoden)
	\end{itemize}
	\item Objekte:
	\begin{itemize}
		\item In der Lage Nachrichten (= Methodenaufrufe) zu empfangen
		\item Daten verarbeiten
		\item Nachrichten senden
		\item können einmal erstellt werden
		\item in verschiedene Kontexten wiederverwendet werden
	\end{itemize}
\end{itemize}


\paragraph{Objektorientierte Analyse(OOA): } Objekte-Konzepte-in Domäne zu finden und zu beschreiben. \\
\paragraph{Objektorientierten Design (OOD): } Geeignete Softwareobjekte und ihr Kollaboration zu definieren um Anforderungen zu erfüllen.

\paragraph{Domänenschicht: } Klassen abgeleitet aus dem Domänenmodell (Low-Representational-Gap)


\subsubsection{Use Cases und System-Sequenzdiagramm}
\paragraph{Basis für das Design: }
\begin{enumerate}
	\item Szenarien
	\item Systemoperationen
	\item Domänenmodell
\end{enumerate}

\subparagraph{Was programmiert werden muss: }
\begin{enumerate}
	\item Systemoperationen bzw. deren Antworten
\end{enumerate}


\paragraph{Use-Case-Realisierung: } Wie ein bestimmter Use Case innerhalb Design mit kollaborierenden Objekten realisiert wird.

\paragraph{Systemoperationen: } Jedes Szeanario schrittweise entworfen und implementiert

\paragraph{UML-Diagramme: } Gemeinsame Sprache um Use-Case-Realisierungen zu veranschaulichen und zu diskutieren.


\subsubsection{Klassen entwerfen: }
Zwei arten von Design-Modellen (ergänzen sich und werden parallel erstellt):
\begin{itemize}
	\item Statische Modelle:
	\begin{itemize}
		\item \textcolor {orange}{UML-Klassendiagramm}- Unterstützen Entwurf Paketen, Klassennamen, Atrributen und Methodensignaturen (ohne Methodenkörperd)
	\end{itemize}
	\item Dynamische Modelle:
	\begin{itemize}
		\item \textcolor {orange} {UML-Interaktionsdiagramme} Untersützen Entwurf der Logik, des Verhaltens des Codes und der Methodenkörper.
	\end{itemize}	
\end{itemize}


\subsection{UML-Diagramme für das Design}
\subsubsection{Grundelemente der UML}
\begin{itemize}
	\item Primitiver Datentyp
	\item Literal
	\item Schlüsselwort, Stereotyp
	\item Randbedingung (constraint)
	\item Kommentar
	\item Diagrammrahmen (optional)
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.3\textwidth]{/Resources/Images/Grundelemente_Klassendiagramm.png}
\caption{\label{fig:Grundelemente_Klassendiagramm}Grundelemente\_Klassendiagramm.}
\end{figure}

\subsubsection{UML-Klassendiagramm}
\begin{itemize}
	\item Statische struktur
	\item Konzeptuell: Problemdomäne (Domänenmodell)
	\item Design: Lösungsdomäne (DCD)
\end{itemize}

\subparagraph{Notationselemente}
\begin{itemize}
	\item Klasse
	\item Attribut
	\item Operation
	\item Sichtbarkeit von Attributen und Operationen
	\item Assoziationsname, Rollen an den Assoziationsenden
	\item Multiplizität (Objekte der betreffenden Klasse)
	\item Navigierbarkeit in Assoziationen
	\item Datentypen und Enumerationen
	\item Generalisierung / Spezialisierung
	\item Abstrakte Klassen
	\item Komposition
	\item Aggregation
	\item Interface
	\item Interface - Realisierung (Menge von öffentlichen Operationen, Merkmalen und Verpflichtungen, die durch eine Klasse, die die Schnittstelle implementiert, zwingend zur Verfügung gestellt werden müssen.
	\item Assoziationsklasse (Da wenn ** Beziehung existiert)
	\item Aktive Klasse (Instanz wird in einem separaten Thread ausgeführt)
\end{itemize}

\subsubsection{UML-Interaktionsdiagramme}

Spezifiziert, auf welche Weise Nachrichten und Daten zwischen Interaktionspartnern ausgetauscht werden. \\

\textcolor {WildStrawberry}{\textbf{2 Arten:}}
\begin{enumerate}
	\item Sequenzdiagramm
	\item Kommunikationsdiagramm
\end{enumerate}

\paragraph{\textcolor {WildStrawberry}{\textbf{Anwendung:}}} Kollaborationen bzw. Informationsaustausch zwischen Objekten zu modellieren.

\begin{itemize}
	\item Wer tauscht mit Wem Information aus?
	\item in welcher Reihenfolge
	\item Zeitlicher Ablauf
	\item Schachtelung und Flussteuerung (Bedingung, Schleifen, Verzweigungen) möglich.
\end{itemize}

\subparagraph{\textcolor {WildStrawberry}{\textbf{Kann in mehreren Perspektiven verwendet werden:}}}
\begin{itemize}
	\item \textcolor {Periwinkle}{Analyse}
	\begin{itemize}
		\item mit SSD Input-/Output-Erignisse (Systemoperationen mit Rückgabeantworten) für ein Szenario eines Use Cases modelliert
	\end{itemize}
	\item \textcolor {Periwinkle}{Design}
	\begin{itemize}
		\item mit SSD Interaktion zwischen Objekten zur Realisierung eines konkreten Use-Case Szenarios zu modellieren
	\end{itemize}
\end{itemize}

\paragraph{Notationselemente:}
\begin{itemize}
	\item Lebenslinie
	\item Aktionssequenz
	\item Synchrone Nachricht
	\item Antwortnachricht
	\item Gefundene, verlorene Nachricht
	\item kombiniertes Fragment
	\item Erzeugnis-, Löschereignis
	\item Selbstaufruf
	\item Interaktionsreferenz
	\item Lebenslinie mit aktiver Klasse
	\item Asynchrone Nachricht
\end{itemize}




	



\subsubsection{UML-Kommunikationsdiagramm}
\paragraph{Beantwortet Frage:}\\
Wer kommuniziert mit werm? Wer arbeitet im System zusammen? Darstellung Informationsaustausch zwischen Kommunikationspartnern. Überblick im Vordergrund.
\paragraph{Notationselemente:}
\begin{itemize}
	\item Lebenslinie (Box)
	\item Synchrone Nachricht (=Aufruf einer Operation)
	\item Antwortnachricht (=Rückgabewert)
	\item Bedingte Nachrichten "[]"
	\item Iteration "*"
	\item Nummerierung der Nachrichten (Festlegung Zeitliche Abfolge)
	\begin{itemize}
		\item Systemoperation (msg1, ohne Nummer)
		\item Nummern gleicher Hierarchie(1,2,3...)
		\item Nummer unterer Hierarchie:
		\begin{itemize}
			\item Werden innerhalb der Operation darüber ausgeführt (verschachtelt)
			\item Operation 1.1:msg3 wird innerhalb von Operation 1:msg2 aufgerufen
		\end{itemize}
	\end{itemize}

\end{itemize}

\subsubsection{UML-Zustandsdiagramm}
\paragraph{Beantwortet zentrale Frage:}\\
Weleche Zustände kann ein Objekt, eine Schnittstelle, ein Use Case, ...bei welchen Ereignissen annehmen?\\
Präzise Abbildung eines Zustandmodells (endlicher Automat):
\begin{itemize}
	\item Zuständen
	\item Ereignissen
	\item Nebenläufigkeiten
	\item Bedingungen
	\item Ein- und Austrittsaktionen
\end{itemize}
\subparagraph{Verwendung:} Modellierung von Echtzeitsystemen, Steuerungen und Protokollen 

\paragraph{Notationselemente:}
\begin{itemize}
	\item Start-, Endzustand
	\item einfacher Zustand
	\item Zusammengesetzter bzw. geschachtelter Zustand
	\item Transition
	\item Orthogonaler Zustand
	\item Parallelisierungsknoten
	\item Synchronisationsknoten
	\item Einstiepunkt
	\item Ausstigespunkt
	\item Unterzustandautomat
	\item Zusammengesetzter Zustand
	\item Flache und tiefe Historie
\end{itemize}


\subsubsection{UML-Aktivitätsdiagramm}
\paragraph{Beantwortet zentrale Frage:}\\
Wie läuft ein bestimmter Prozess oder ein Algortithmus ab?\\
Detaillierte Visualisierung von Abläufen:
\begin{itemize}
	\item Bedingungen
	\item Schleifen
	\item Verweigungen
\end{itemize}

Parallelisierung und Synchronisation von Aktionen möglich.

\paragraph{Notationselemente:}
\begin{itemize}
	\item Aktivität
	\item Aktionsknoten (Aktion)
	\item Objektknoten (Objekt)
	\item Entscheidungs- und Vereinigungsknoten
	\item Initialknoten
	\item Aktivitätsendknoten
	\item Partition / Swimlane
	\item Parallelisierungsknoten
	\item Synchronisationsknoten
	\item SendSignal-Aktion
	\item Ereignis- bzw. Zeitereignisannahmeaktion
	\item CallBehavior-Aktion
\end{itemize}


\subsection{Verantwortlichkeiten und Responsibility-Driven-Design}:
Methode über Entwurf Softwareklassen nachzudenken:
\textcolor {yelloworange} {\textbf{Verantwortlichkeiten, Rollen, Kollaborationsbeziehungen}} = \textbf{RDD / Responsibility Driven Design}\\

Softwareobjekte haben Verantwortlichkeiten und arbeiten mit anderen Objekten zusammen.\\
Verantwortlichkeiten werden durch Attribute und Methoden implementiert.\\
Kann auf jeder Ebene des Designs angwendet werden:
\begin{itemize}
	\item Klasse
	\item Komponente
	\item Schicht
\end{itemize}


\paragraph{2 Ausprägungen von Verantwortlichkeiten:}
\subparagraph{\textcolor {brick}{\textbf{Doing-Verantwortlichkeiten / Algorithmen, Code:}}
\begin{itemize}
	\item Selbst etwas tun
	\item Aktionen anderer Objekte anstossen
	\item Aktivitäten anderer Objekte kontrollieren und steuern
\end{itemize}

\subparagraph{\textcolor {brick}{\textbf{Knowing-Verantwortlichkeit / Daten, Attribute: }}
\begin{itemize}
	\item Private eingekapselte Daten
	\item Dinge kennen, die es ableiten oder berechnen kann
	\item Daten/Objekte zur Verfügung stellen, die aus bekannten Daten/Objekten abgeleitet oder berechnet werden können
\end{itemize}


\subsubsection{GRASP- 9 Patterns}
\begin{enumerate}
	\item \textbf{Information Expert}
	\begin{itemize}
		\item \textcolor {teal} {Derjenige, der was weiss}
	\end{itemize}
	\item \textbf{Creator}
		\begin{itemize}
		\item \textcolor {teal} {Zuständig erstellen Objekte(new())im Framework ABER delegiert als Dependency Injection}
	\end{itemize}
	\item \textbf{Controller /Domain Controller = Service}
	\item \textbf{Low Coupling}
		\begin{itemize}
		\item \textcolor {teal} {Weniger Abhängigkeiten}
	\end{itemize}
	\item \textbf{High Cohesion}
		\begin{itemize}
		\item \textcolor {teal} {Abhängigkeiten zusammentun}
	\end{itemize}
	\item \textbf{Polymorphism}
		\begin{itemize}
		\item \textcolor {teal} {Unterschiedliche Objekte können gleiche Nachricht empfangen und interpretieren}
	\end{itemize}
	\item \textbf{Pure Fabrication}
	\item \textbf{Indirection}
	\item \textbf{Protected Variations}
\end{enumerate}

\subsubsection{Information Expert}

Lösung:\\
Verantwortlichkeit einer Klasse zuweisen, die über die erforderlichen Informationen verfügt, um sie zu erfüllen. Partielle Verantwortlichkeiten sind auch möglich.\\
Alternativen:\\
Low Coupling, High Cohesion (Künstliche Klasse)



\subsubsection{Creator}
Denn Nachteil von new..() = Kopplung\\
Lösung:\\
\textbf {Klasse A} zuständig eine neue Instanz einer \textbf{Klasse B} zu erzeugen, wenn eine oder mehrerere der folgenden Aussagen wahr ist(je mehr desto besser):\\
\begin{itemize}
	\item A eine Aggregation oder ein Kompositum von B
	\item A registriert oder erfasst B-Objekte
	\item A arbeitet eng mit B-Objekten zusammen oder hat enge Kopplung
	\item A verfügt über Initialisierungsdaten für B (A ist Experte bezüglich Erzeugung von B)
\end{itemize}
Wenn mehrere Optionen anwendbar sind, Klasse A vorziehen, die ein Aggregat oder ein Kompositum ist.\\
Alternative:\\
Factory Pattern, Dependency Injection(DI)

\subsubsection{Controller}

Service = 1.Schicht = Domain Controller\\
Welches erste Objekt jenseits der UI-Schicht empfängt und koordiniert(kontrolliert) eine Systemoperation?\\
Lösung:\\
Verantwortlichkeit der Klasse zuweisen, der eine der folgenden Bedingungen erfüllt:\\
\begin{itemize}
	\item 
\end{itemize}

\begin{figure} [H]
\centering
\includegraphics[width=0.3\textwidth]{\Resources\Images\Controller.png}
\caption{\label{fig:Controller}Controller.}

\end{figure}



























































































\end{document}