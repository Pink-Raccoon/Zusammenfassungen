\documentclass[../ZF_HM2.tex]{subfiles}


\begin{document}

\newmdtheoremenv[%
  backgroundcolor=white,
  linecolor=magenta!,
  linewidth=2pt,
  topline=true,
  rightline=true,
  leftline=true]{theorem}{}

\subsection{Partielle Ableitungen}

$m = f'(x_0)$ im Punkt $(x_0,f(x_0)$
\paragraph{Tangentengleichung}
\subparagraph{Beispiel:}P(1,3)\\ \\
$t_x = \underbrace{f(x_1,x_2)}_\text{\colorbox{pink!30}{f(1,3)}} + \underbrace{\dfrac{\delta f}{\delta x_1}(x_1^{(0)},x_2^{(0)})}_\text{\colorbox{pink!30}{nach $x_1$}} *
(x_1-x_1^{(0)})+
\underbrace{\dfrac{\delta f}{\delta x_2}(x_1^{(0)},x_2^{(0)}}_\text{\colorbox{pink!30}{nach $x_2$}} 
*(x_2-x_2^{(0)})$

\subsection{Linearisierung von Funktionen}
\paragraph{Jacobi-Matrix Df(x) \\}
Jacobi-Matrix enth√§lt s√§mtliche partiellen Abl.1.Ord.von f:\\

$\left[\begin{matrix}\dfrac{\delta f_1}{\delta x_1} & \dfrac{\delta f_1}{\delta x_2} & ...& \dfrac{\delta f_1}{\delta x_n}\\\\
\dfrac{\delta f_2}{\delta x_1} & \dfrac{\delta f_2}{\delta x_2} & ...& \dfrac{\delta f_2}{\delta x_n}\\\\
\dfrac{\delta f_m}{\delta x_1} & \dfrac{\delta f_m}{\delta x_2} & ...& \dfrac{\delta f_m}{\delta x_n}\end{matrix}\right]$
\\
\textbf{Beispiel:\\}

$f(x) = \left[\begin{matrix}f_1(x_1,x_2)\\
f_2(x_1,x_1)\end{matrix}\right] = \left[\begin{matrix}x_1^{2} + x_2 -11\\
 x_1+x_2^{2}  -7\end{matrix}\right] $
\\ \\
$x^{(0)} = (1,1)^{T}$ 
\\
\textbf{Partielle Ableitung:}\\
$Df(x_1,x_2) = \left[\begin {matrix}2x_1 & 1\\
1 & 2x_2\end{matrix}\right]$

\textbf{An der Stelle $x^{(0)}$: }\\

$Df(x_1^{(0)},x_2^{(0)}) = \left[\begin {matrix}2 & 1\\
1 & 2\end{matrix}\right]$

\textbf{Linearisierung:}\\
$g(x)= f(x^{(0)})+Df(x^{(0)})*(x-x^{(0)})$

$g(x_1,x_2) = \left[\begin {matrix}-9 \\
-5\end{matrix}\right] + \left[\begin {matrix}2 & 1\\
1 & 2\end{matrix}\right] * \left[\begin {matrix}x_1 - 1\\
x_2 -1\end{matrix}\right] = \left[\begin {matrix}2x_1+x_2-12\\
x_1+2x_2-8\end{matrix}\right]$

\textbf{Gleichung der Tangentialebene:} \\
Alle angelegten Tangenten an die Bildfl√§che $y=f(x-1,x_2)$ im Fl√§chenpunkt $P=f(x_1^{(0)},x_2^{(0)})$

\subsection{Das Newton-Verfahren f√ºr Systeme}
\begin{itemize}
	\item Konvergiert quadratisch wenn Df(x) regul√§r, und f 3-mal stetig differenzierbar ist.
	\item Vereinfachtes Newton Verfahren konvergiert linear.
\end{itemize}

\textbf{M√∂gliche Abbruchkriterien: $\in > 0$}\\
\begin{enumerate}
	\item $n \geq n_{max}$ (bestimmte Anzahl Iterationen)
	\item $\| x^{n+1}-x^{n}\| \leq \| x^{n+1}\| * \in$ (relativer Fehler)
	\item $\| x^{n+1}-x^{n}\| \leq \in$ (absoluter Fehler)
	\item $\|f(x^{n+1})\| \leq \in$ (max residual)
\end{enumerate}

\begin{mdframed}
	\textbf{Algorithmus:\\}
	\begin{enumerate}
		\item $Df(x^{n})\delta ^{n} = -f(x^{(n)})$
		\item nach $\delta ^{n}$ aufl√∂sen
		\item $x^{n+1} = x^{n} +\delta ^{n} $
	\end{enumerate}
\end{mdframed}

\subsubsection{Vereinfachtes Newton-Verfahren}
Konvergiert nur noch linear!!\\
Nat√ºrlich deutlich langsamer!\\

Immer wieder $Df(x^{0}) verwenden$

\begin{mdframed}
	\textbf{Algorithmus:\\}
	\begin{enumerate}
		\item $Df(x^{0})\delta ^{n} = -f(x^{(n)})$
		\item nach $\delta ^{n}$ aufl√∂sen
		\item $x^{n+1} = x^{n} +\delta ^{n} $
	\end{enumerate}
\end{mdframed}



\subsubsection{Ged√§mpftes Newton-Verfahren}

Nach dem n-ten Schritt wenn $Df(x^{n})$ schlecht konditioniert ist (nicht oder fast nicht invertierbar), dann $x^{n} +\delta ^{n}$ verwerfen!!\\
Funktioniert auch mit vereinfachtes Newton Verfahren.		

\begin{theorem}
	\textbf{Probieren:\\\\}
	$x^{n} + \dfrac{\delta ^{n}} {2}$\\\\
	Mit der Bedingung:\\
	$\|f(x^{n}) + \dfrac{\delta ^{n}} {2})\|_2 < \|f(x^{n} \|_2$ \\\\
	Weil wir Iteration $\|f(x^{n}) \|_2$ gegen 0 erreichen wollen
	 
\end{theorem}

\pagebreak

\begin{mdframed}
	\textbf{Algorithmus:\\}
	\begin{enumerate}
		\item $Df(x^{n})\delta ^{n} = -f(x^{(n)})$
		\item nach $\delta ^{n}$ aufl√∂sen
		\item Finde minimale aus $k \in \|f(x^{n}) + \dfrac{\delta ^{n}} {2})\|_2 < \|f(x^{n} \|_2$ $,k_{max} = 4$\\
		sofern nichts Anderes als sinnvoll angegeben\\
 \UseRawInputEncoding
\begin{lstlisting}[language=Python]
	while k <= k_max:
		new_residual = np.linalg.norm
		(f_lambda(x_n + (delta.reshape(x0.shape[0], ) / 
		(2 ** k))), 2) 
# ‚Äñf(x(n) + ùõÖ(n) / 2^k)‚Äñ‚ÇÇ
	        if new_residual < last_residual:
	        		delta = delta / (2**k)
	        		x_next = x_n + 
	        		delta.reshape(x0.shape[0], )  
# x(n+1) = x(n) + ùõÖ(n) / 2^k
				k_actual = k
	                break  
# Minimales k, f√ºr welches das Residuum besser ist wurde gefunden 
-> abbrechen
	            else:
	            		k=0
	 k += 1
            		

\end{lstlisting}
		
		\item $x^{n+1} = x^{n} +\dfrac{\delta ^{n}}{2^{k}} $\\

	\end{enumerate}
\end{mdframed}







 


















\end{document}